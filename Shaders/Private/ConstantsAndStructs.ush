#pragma once

#define EMPTY 0
#define TAKEN 1
#define NAN asfloat(0xffffffff)
#define UNDEFINED_INT -2147483647
#define UNDEFINED_FLOAT3 float3(340000000000000000000000000000000.0f, 340000000000000000000000000000000.0f, 340000000000000000000000000000000.0f)

#define VOLUME_MOD 1.6119919540164696407169668466392849389446140723238615

#define NAN asfloat(0xffffffff)
#define GRP_SIZE_VOXELS 128
#define GRP_SIZE_PARTICLES 1024
#define EXTRA_PARTICLES_IN_VOXEL 0

#define VELOCITY(p) ((p).VelocityAndMass.xyz)
#define MASS(p) ((p).VelocityAndMass.w)

#define CP_POSITION(p) ((p).PositionAndRadius.xyz)
#define FP_POSITION(p) ((p).PositionAndEase.xyz)
#define RADIUS(p) ((p).positionAndRadius.w)
#define EASE(p) ((p).positionAndEase.w)

struct CoarseParticle
{
    float4 PositionAndRadius; // xyz is position, w is particle radius
    float4 VelocityAndMass; // xyz is velocity, w is mass
};

struct FineParticle
{
    float4 PositionAndEase; // xyz is position, w is particle ease
    float4 VelocityAndMass; // xyz is velocity, w is particle mass
};

uint Hash(uint In_X)
{
    In_X += (In_X << 10u);
    In_X ^= (In_X >> 6u);
    In_X += (In_X << 3u);
    In_X ^= (In_X >> 11u);
    In_X += (In_X << 15u);
    return In_X;
}

// Construct a float with half-open range [0:1] using low 23 bits.
// All zeroes yields 0.0, all ones yields the next smallest representable value below 1.0.
float FloatConstruct(uint In_M)
{
    const uint IeeeMantissa = 0x007FFFFFu; // binary32 mantissa bitmask
    const uint IeeeOne = 0x3F800000u; // 1.0 in IEEE binary32

    In_M &= IeeeMantissa; // Keep only mantissa bits (fractional part)
    In_M |= IeeeOne; // Add fractional part to 1.0

    float NewFloat = asfloat(In_M); // Range [1:2]
    return NewFloat - 1.0; // Range [0:1]
}

float Random(uint In_X)
{
    return FloatConstruct(Hash(In_X));
}

float Distance2(float3 In_Point1, float3 In_Point2)
{
    float3 Vec = In_Point1 - In_Point2;
    return dot(Vec, Vec);
}

int3 GetVoxelIndexFromWorldPos(float3 In_Position, float In_VoxelSize)
{
    In_Position /= In_VoxelSize;
    In_Position += sign(In_Position) * 0.5;
    
    return int3((int) In_Position.x, (int) In_Position.y, (int) In_Position.z);
}

